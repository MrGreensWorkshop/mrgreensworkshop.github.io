[ { "title" : "Zephyr RTOS Real Application Tutorial series" ,"category" : "microcontrollers" ,"tags" : "raspberry pi pico, zephyr rtos" ,"url" : "/posts/2023-03-24-raspberry-pi-pico-zephyr-rtos-picodro" ,"date" : "Mar 24, 2023" ,"content" : "In this post, I’ll walk you through the process of creating a real Zephyr RTOS application based on the Raspberry Pi Pico. I assume that you have finished all the other episodes. Please watch all Zephyr RTOS tutorial videos to better understand the subject. Introduction Since I promised to make a real application with Zephyr RTOS, I decided it would be more informative to build a tutorial around an actual, functional application. So I decided to remake the PicoDRO application using Zephyr RTOS. It is dedicated to learning Zephyr RTOS drivers, devicetrees, modules, pin control, overlays, macros, and more. The requirement for RTOS is out of scope for the content. PicoDRO is an open-source digital readout project that reads linear scales (encoders) with the Raspberry Pi Pico and Pico SDK. This video demonstrates how it is designed and works. Here is the PicoDRO repository, which also contains a circuit schematic, etc. I took my time breaking down this project into small pieces to make it easy to understand. All tags are compilable and executable. Some tags have a slightly different readme file that specifies compilation than others. Thank you for considering supporting my work! Tags and video links As I post new tutorial videos for the Real Application series, I will add new tags to the repo. v1.0.0 VS Code environment settings for Linux, macOS, and Windows. Debug config is added. v1.1.0 Setting USB CDC ACM as console output. v1.2.0 DTR line control for logging. v1.3.0 Setting USB CDC ACM as the default console. Preparation I assume you have; Finished the Zephyr development environment setup. It is covered in this video. Zephyr RTOS source code on the paths below. Linux or macOS Windows cd ~/zephyrproject cd %USERPROFILE%/zephyrproject Installed VS Code. (not mandatory) If so, you are good to go. At each part, execute the command specified in the part that applies to you. When you get to the end of the page, the application will have been compiled and will be running. * Except as otherwise specified, the commands are the same for Linux, macOS, and Windows. * The commands were tested on Linux (Ubuntu 22.04), macOS (Ventura 13.2), and Windows (10). Initialization Please choose your desired project type (workspace app or freestanding app) and follow the instructions below. I will be using the workspace application in the tutorial videos. Then select a tag and replace &lt;tag_name&gt; with your preferred tag (for example, v1.0.0) in the commands below. For more about Zephyr RTOS application types, please watch this video. Initialization as a workspace application 1. Navigate to the project’s desired location by changing the directory. Linux or macOS Windows cd ~/Desktop cd %USERPROFILE%/Desktop 2. Initialize the workspace. # initialize the workspace west init -m https://github.com/MrGreensWorkshop/ZephyrOS_RasPiPico_PicoDRO --mr &lt;tag_name&gt; PicoDRO # cd to project and update Zephyr modules cd PicoDRO west update * Please don’t forget to comment the terminal.integrated.env settings in .vscode/settings.json. Initialization as a freestanding application 1. Navigate to Zephyr RTOS source code directory. Linux or macOS Windows cd ~/zephyrproject cd %USERPROFILE%/zephyrproject 2. For this project, we will be using Zephyr v3.2.0, so we need to switch zephyrproject/zephyr to it. Or if you don’t want to change your zephyrproject then go to step 3. # switch to zephyr v3.2.0 git -C zephyr checkout tags/v3.2.0 # update Zephyr modules west update 3. If you already ran the commands in step 2, jump to step 4. Rename the current zephyrproject and get Zephyr v3.2.0, as shown below. Linux or macOS # rename the current zephyrproject directory move ~/zephyrproject ~/zephyrproject_old # initialize west init --mr v3.2.0 ~/zephyrproject # cd to project and update Zephyr modules cd ~/zephyrproject west update Windows # rename the current zephyrproject directory move %USERPROFILE%/zephyrproject %USERPROFILE%/zephyrproject_old # initialize west init --mr v3.2.0 %USERPROFILE%/zephyrproject # cd to project and update Zephyr modules cd %USERPROFILE%/zephyrproject west update 4. Clone the repository as shown below, or download the desired tag from the release page. git clone -b &lt;tag_name&gt; https://github.com/MrGreensWorkshop/ZephyrOS_RasPiPico_PicoDRO.git * Please don’t forget to uncomment the terminal.integrated.env settings in .vscode/settings.json as mentioned in the build process below. Build process 1. Setting up environment variables Workspace application Using VS Code No action is required. If you are not planing to use debugging you can delete the .vscode directory at all. Using the Shell or Command Prompt No action is required. Freestanding application Using VS Code Open the .vscode/settings.json file and uncomment terminal.integrated.env settings. Reopen the project directory in VS Code after making any modifications to the .vscode/settings.json file. Please don’t forget to reopen the project directory in VS Code after changing tags. Since environment variables may differ between tags. Using the Shell or Command Prompt Please make sure to set environment variables using the following command when using Shell or Command Prompt (not PowerShell). Linux or macOS Windows source ~/zephyrproject/zephyr/zephyr-env.sh %USERPROFILE%/zephyrproject/zephyr/zephyr-env.cmd 2. Building Some tags may have different build commands. Please refer to the readme file on the project repo for each tag for build commands. Running 1. Put the Raspberry Pi Pico into bootloader mode by pushing the bootsel button while plugging it into your computer. Or you can use PicoProbe to write the binary. For more about that, check out Debugging. 2. Copy the build/zephyr/zephyr.uf2 file to the Raspberry Pi Pico either by dragging and dropping or using the cp command as shown below. Linux macOS cp build/zephyr/zephyr.uf2 /media/&lt;user&gt;/RPI-RP2 cp build/zephyr/zephyr.uf2 /Volumes/RPI-RP2 3. Getting Console Output Please make sure to build with the desired configuration (USB or UART). USB configuration available with and after tag v1.1.0. Using Raspberry Pi Pico USB CDC ACM (built with USB configuration) Please connect to your PC via USB. Using UART0 over USB serial adapter (built with UART configuration) Please connect its UART0 to your PC via the USB serial adapter. Pin Function USB / Serial converter 1 UART0 TX RX 2 UART0 RX TX 3 GND GND Using PicoProbe as USB serial adapter When you are using PicoProbe just as a USB serial adapter, you don’t need to install anything on your PC. Connect your target Raspberry Pi Pico to PicoProbe. As shown in the schematic diagram, connect three Serial I/F pins. Please make sure DTR is turned on. Otherwise, you will not get serial output. Final step Open your favorite serial terminal app and set the baud rate to 115200, then open the corresponding serial port. Debugging For more about debugging on Zephyr RTOS using PicoProbe, please watch this video. You can also check this blog post for the circuit diagram and how to guide. 1. Connect your target Raspberry Pi Pico to PicoProbe. As shown in the schematic diagram, connect three pins each for SWD I/F and Serial I/F pins. 2. For debugging set the svdFile on .vscode/launch.json file based on your project configuration (freestanding app or workspace app). You Can Support My Work Creating projects like this takes a great amount of time. Much appreciated if you consider supporting me so that I can continue projects like this and creating new contents for everyone. You might consider supporting me via GitHub Sponsors, Patreon, or Ko-fi. For links, please see the About page. Credits I’d like to thank all project(s) that gave me an opportunity to make this project possible. Zephyr Project is a scalable real-time operating system (RTOS) supporting multiple hardware architectures, optimized for resource constrained devices, and built with security in mind. Final words You can access the dedicated repository through this link. Tell me what you think in the comments. To be continued…" },{ "title" : "Let's create a Pico SDK based Bluetooth Classic SPP example with the Raspberry Pi Pico W in VS Code" ,"category" : "microcontrollers" ,"tags" : "raspberry pi pico w, pico sdk, bluetooth" ,"url" : "/posts/2023-02-16-raspberry-pi-pico-w-bluetooth-classic-spp" ,"date" : "Feb 15, 2023" ,"content" : "In this post I will talk about, how to create a Pico SDK based Bluetooth Classic SPP example with the Raspberry Pi Pico W in VS Code. Introduction Pico SDK v1.5.0 includes Bluetooth support for the Raspberry Pi Pico W, including both Bluetooth Low Energy (BLE) and Bluetooth Classic. They also released many examples. I thought it would be better if I gave a simple example for anyone who wants to use Bluetooth Classic SPP. Bluetooth Serial Port Profile(SPP) emulates serial ports over Bluetooth. You can send or receive data from your Raspberry Pi Pico W to your Android phone, PC, etc. over Bluetooth. Thank you for considering supporting my work! Compilation Clone the repo as shown below, or download latest release. git clone https://github.com/MrGreensWorkshop/RasPiPicoSDK_BT_Classic_SPP.git Please make sure you are using the Pico SDK v1.5.0 or later. Open the project in VS Code because it adds SDK to the environment string. (Check the .vscode/settings.json file for details.) Or add PICO_SDK_PATH to your environment string. Compile using build.sh chmod +x build.sh ./build.sh Or run cmake -B build -S . &amp;&amp; make -j4 -C build Running Get the binary or compile the project. You can compile the project and get the binary as explained above. Or you can use precompiled binary files from the latest release, download the “binary.zip” and unzip. Put the Raspberry Pi Pico into bootloader mode by pushing the bootsel button while plugging it into your computer. Copy the build/PicoBTSPP.uf2 file to the Raspberry Pi Pico W either by dragging and dropping or using the cp command as shown below. Linux macOS cp build/PicoBTSPP.uf2 /media/&lt;user&gt;/RPI-RP2 cp build/PicoBTSPP.uf2 /Volumes/RPI-RP2 Connect to your Raspberry Pi Pico W to your PC. Check out CMakeLists.txt file for STDIO settings. Using USB CDC (Default Setting) Redirect STDIO to USB CDC. # Enable or Disable UART pico_enable_stdio_uart(${PROJECT_NAME} 0) # Enable or Disable USB CDC pico_enable_stdio_usb(${PROJECT_NAME} 1) Please connect Raspberry Pi Pico W to your PC via USB. Using UART0 over USB serial adapter Redirect STDIO to UART0. # Enable or Disable UART pico_enable_stdio_uart(${PROJECT_NAME} 1) # Enable or Disable USB CDC pico_enable_stdio_usb(${PROJECT_NAME} 0) Please connect Raspberry Pi Pico W’s UART0 to your PC via the USB serial adapter. Pin Function USB / Serial converter 1 UART0 TX RX 2 UART0 RX TX 3 GND GND Open your favorite serial terminal app and set the baud rate to 115200, then open the corresponding serial port. Search for Bluetooth device name “SPP Counter XX:XX:XX:XX:XX:XX” from your PC or Android phone. For Android you can use Serial Bluetooth Terminal. You can find its source code here. After connecting to your device, you can see that the Raspberry Pico W sends BTstack counter XXXX to your device. If you type something and tap to send button, you can see RCV: 'text' on your PC’s terminal. You Can Support My Work Creating projects like this takes a great amount of time. Much appreciated if you consider supporting me so that I can continue projects like this and creating new contents for everyone. You might consider supporting me via GitHub Sponsors, Patreon, or Ko-fi. For links, please see the About page. Final words You can access the dedicated repository through this link. Tell me what you think in the comments. What do you want to see on my blog or YouTube channel?" },{ "title" : "Let's create Zephyr RTOS based app and start debugging with Raspberry Pi Pico in VS Code" ,"category" : "microcontrollers" ,"tags" : "raspberry pi pico, zephyr rtos, picoprobe" ,"url" : "/posts/2022-06-10-raspberry-pi-pico-zephyr-os-part-2" ,"date" : "Jun 10, 2022" ,"content" : "In this post I will talk about, how to create Zephyr based applications and how to debug on Raspberry Pi Pico. I assume that you have finished set up the development environment. This video explains how to set up the development environment, so please watch it first if needed. Pick a sample application Let’s pick a sample application, close enough to what we want to do. This time I need a sample for external GPIO Interrupts. Let’s check Zephyr sample applications. $ cd ~/zephyrproject/zephyr/samples $ ls application_development drivers posix arch hello_world sensor basic index.rst shields bluetooth kernel subsys boards modules synchronization classic.rst net tfm_integration compression philosophers userspace $ cd basic $ ls basic.rst blinky_pwm fade_led rgb_led threads blinky button minimal servo_motor $ cd button $ ls CMakeLists.txt README.rst prj.conf sample.yaml src Let’s check button sample’s source code. Here is the GPIO interrupt config. cat src/main.c ... void main(void) { ... ret = gpio_pin_interrupt_configure_dt(&amp;button, GPIO_INT_EDGE_TO_ACTIVE); ... gpio_init_callback(&amp;button_cb_data, button_pressed, BIT(button.pin)); gpio_add_callback(button.port, &amp;button_cb_data); ... } I will use this sample for my application base. How to make standalone Zephyr-based applications There are 3 types of applications. Applications in zephyrproject/zephyr/ folder called as Zephyr repository applications. Applications in zephyrproject/ folder called as Zephyr workspace applications. Applications outside of zephyrproject folder called as Zephyr freestanding applications. &lt;home&gt;/ ├─── zephyrproject/ │ ├─── .west/ │ │ └─── config │ ├─── zephyr/ │ │ ├── arch/ │ │ ├── boards/ │ │ ├── cmake/ │ │ ├── samples/ │ │ │ ├── hello_world/ -&gt; Zephyr repository application │ │ │ └── ... │ │ ├── tests/ │ │ └── ... │ ├── bootloader/ │ ├── modules/ │ ├── ... │ └── applications/ │ └── app/ -&gt; Zephyr workspace application │ └─── app/ -&gt; Zephyr freestanding application ├── CMakeLists.txt ├── prj.conf └── src/ └── main.c Zephyr Project Reference: Application Development This time I will use freestanding application. Let’s start by copying the button sample folder. Please don’t use spaces for folder names. Otherwise it will not work. cd ~/ cp -R ~/zephyrproject/zephyr/samples/basic/button ~/Desktop/gpio_int_test First I will try to compile for nucleo board because button sample does work with no change. $ cd ~/Desktop/gpio_int_test $ west build -b nucleo_f411re usage: west [-h] [-z ZEPHYR_BASE] [-v] [-V] &lt;command&gt; ... west: error: argument &lt;command&gt;: invalid choice: 'build' (choose from 'init', 'update', 'list', 'manifest', 'diff', 'status', 'forall', 'help', 'config', 'topdir', 'selfupdate') $ According to documentation, we need to set some environment variables. But don’t rush, we will fix this later. Zephyr Project Reference: Environment Variables Temporarily, I will run Zephyr environment script. With this, environment variables last until terminal closes. $ source ~/zephyrproject/zephyr/zephyr-env.sh $ west build -b nucleo_f411re -- west build: generating a build system Loading Zephyr default modules (Zephyr base). -- Application: /Users/user/Desktop/gpio_int_test -- Found Python3: /usr/local/opt/python@3.9/bin/python3.9 (found suitable exact version \"3.9.13\") found components: Interpreter -- Cache files will be written to: /Users/user/Library/Caches/zephyr -- Zephyr version: 3.0.99 (/Users/user/zephyrproject/zephyr) -- Found west (found suitable version \"0.13.1\", minimum required is \"0.7.1\") -- Board: nucleo_f411re ... [156/156] Linking C executable zephyr/zephyr.elf Memory region Used Size Region Size %age Used FLASH: 15108 B 512 KB 2.88% SRAM: 4416 B 128 KB 3.37% IDT_LIST: 0 GB 2 KB 0.00% Successfully compiled. VS Code project setup Let’s setup standalone Zephyr application on VS Code. Open the project folder we just copied in VS Code. Delete build folder. Let’s add Zephyr environment variables to VS Code. With this, environment variables are added to VS Code’s terminal. Create a new folder named .vscode Create a new file named settings.json inside of it. Copy and paste the config written below. { \"terminal.integrated.env.osx\": { \"PATH\": \"$HOME/zephyrproject/zephyr/scripts\", \"ZEPHYR_BASE\": \"${env:HOME}/zephyrproject/zephyr\", }, \"terminal.integrated.env.linux\": { \"PATH\": \"$HOME/zephyrproject/zephyr/scripts:${env:PATH}\", \"ZEPHYR_BASE\": \"${env:HOME}/zephyrproject/zephyr\", }, \"terminal.integrated.env.windows\": { \"PATH\": \"${env:USERPROFILE}\\\\zephyrproject\\\\zephyr\\\\scripts;${env:PATH}\", \"ZEPHYR_BASE\": \"${env:USERPROFILE}\\\\zephyrproject\\\\zephyr\", }, } You can find more about VS Code workspace settings from here. Then reopen the VS Code open terminal inside VS Code and try to compile. $ west build -b nucleo_f411re -- west build: generating a build system Loading Zephyr default modules (Zephyr base). -- Application: /Users/user/Desktop/gpio_int_test -- Found Python3: /usr/local/opt/python@3.9/bin/python3.9 (found suitable exact version \"3.9.13\") found components: Interpreter -- Cache files will be written to: /Users/user/Library/Caches/zephyr -- Zephyr version: 3.0.99 (/Users/user/zephyrproject/zephyr) -- Found west (found suitable version \"0.13.1\", minimum required is \"0.7.1\") -- Board: nucleo_f411re ... [156/156] Linking C executable zephyr/zephyr.elf Memory region Used Size Region Size %age Used FLASH: 15108 B 512 KB 2.88% SRAM: 4416 B 128 KB 3.37% IDT_LIST: 0 GB 2 KB 0.00% Successfully compiled. Let’s set our board name. Open the CMakeLists file and add this set(BOARD rpi_pico) after cmake_minimum_required ... cmake_minimum_required(VERSION 3.20.0) set(BOARD rpi_pico) ... Let’s try to build without board option. $ west build -p ... /Users/user/Desktop/gpio_int_test/src/main.c:22:2: error: #error \"Unsupported board: sw0 devicetree alias is not defined\" 22 | #error \"Unsupported board: sw0 devicetree alias is not defined\" | ^~~~~ [117/160] Building C object zephyr/drivers/gpio/CMakeFiles/drivers__gpio.dir/gpio_rpi_pico.c.obj ninja: build stopped: subcommand failed. FATAL ERROR: command exited with status 1: /usr/local/bin/cmake --build /Users/user/Desktop/gpio_int_test/build We have compile error because raspberry pi pico board doesn’t have switch. Adding switch0 Let’s add switch0, for this we will use app overlay file. Let’s check switch0 definition in nucleo board’s device overlay file. $ cat /Users/wizard/zephyrproject/zephyr/boards/arm/nucleo_f411re/nucleo_f411re.dts ... / { gpio_keys { compatible = \"gpio-keys\"; user_button: button { label = \"User\"; gpios = &lt;&amp;gpioc 13 GPIO_ACTIVE_LOW&gt;; }; }; aliases { led0 = &amp;green_led_2; sw0 = &amp;user_button; }; }; ... Let’s create a new app.overlay file and put what we need in it. / { gpio_keys { compatible = \"gpio-keys\"; user_button: button { label = \"User\"; gpios = &lt;&amp;gpio0 28 GPIO_ACTIVE_LOW&gt;; }; }; aliases { sw0 = &amp;user_button; }; }; Zephyr Project Reference: Devicetree HOWTOs In my circuit, the switch connected to GPIO 28. I will show the schematic later. Let’s try to compile. $ west build -p WARNING: This looks like a fresh build and BOARD is unknown; so it probably won't work. To fix, use --board=&lt;your-board&gt;. Note: to silence the above message, run 'west config build.board_warn false' -- west build: generating a build system ... [160/160] Linking C executable zephyr/zephyr.elf Memory region Used Size Region Size %age Used BOOT_FLASH: 256 B 256 B 100.00% FLASH: 11940 B 2096896 B 0.57% SRAM: 3760 B 264 KB 1.39% IDT_LIST: 0 GB 2 KB 0.00% Converting to uf2, output size: 24576, start address: 0x10000000 Wrote 24576 bytes to zephyr.uf2 $ gpio_int_test % Voilà! Our binary file is located in build/zephyr folder. For more about west command please check the link below. Zephyr Project Reference: Building, Flashing and Debugging How to debug? On-chip debugging with Zephyr RTOS + App on Raspberry Pi Pico What we need? Hardware debugger interface (SWD) A Raspberry Pi Pico flashed with picoprobe firmware Software for on-chip debugging OpenOCD build for picoprobe Arm toolchain arm-none-eabi-gdb Cortex-Debug extension for VS Code For on-chip debugging we need some hardware and software. Let’s prepare one by one. Hardware debugger interface First hardware, I will use picoprobe for Hardware debugger interface. Let’s get the compiled binary for picoprobe and flash to Raspberry Pi Pico. Open this link. Find the link under the title Debugging using another Raspberry Pi Pico and download from Download the UF2 file Put the Raspberry Pi Pico into bootloader mode by pushing bootsel button, while plugging to your computer. Then copy the UF2 file to your Pico’s storage. $ cp ~/Downloads/picoprobe.uf2 /Volumes/RPI-RP2/ Building OpenOCD Currently OpenOCD does not officially support the picoprobe. So, we need to build a specific version of OpenOCD. For macOS cd ~/ brew install libtool automake libusb wget pkg-config gcc texinfo git clone https://github.com/raspberrypi/openocd.git --branch picoprobe --depth=1 cd openocd export PATH=\"/usr/local/opt/texinfo/bin:$PATH\" ./bootstrap ./configure --enable-picoprobe --disable-werror make -j4 For Linux cd ~/pico sudo apt install automake autoconf build-essential texinfo libtool libftdi-dev libusb-1.0-0-dev git clone https://github.com/raspberrypi/openocd.git --branch picoprobe --depth=1 --no-single-branch cd openocd ./bootstrap ./configure --enable-picoprobe make -j4 sudo make i Since this is a Pico-specific version of OpenOCD, you don’t need to run “make install”. We will add OpenOCD’s paths to VS Code later. Let’s check the OpenOCD. $ ~/openocd/src/openocd --version Open On-Chip Debugger 0.11.0-g4f2ae61 (2022-06-08-15:59) Licensed under GNU GPL v2 For bug reports, read http://openocd.org/doc/doxygen/bugs.html Installing ARM tools For macOS cd ~/ brew tap eblot/armeabi brew install arm-none-eabi-gdb Let’s check the arm-none-eabi-gdb. $ arm-none-eabi-gdb --version GNU gdb (GDB) 10.1 Copyright (C) 2020 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. VS Code Settings First install Cortex-Debug extension. Open settings.json file and add OpenOCD binary path. { \"cortex-debug.openocdPath\": \"${env:HOME}/openocd/src/openocd\", ... Create a new file named launch.json inside of .vscode folder and add all these settings. { \"version\": \"0.2.0\", \"configurations\": [{ \"name\": \"Pico Zephyr Debug\", \"device\": \"RP2040\", \"gdbPath\": \"arm-none-eabi-gdb\", \"cwd\": \"${workspaceRoot}\", \"executable\": \"build/zephyr/zephyr.elf\", \"request\": \"launch\", \"type\": \"cortex-debug\", \"servertype\": \"openocd\", \"configFiles\": [ \"/interface/picoprobe.cfg\", \"/target/rp2040.cfg\" ], \"searchDir\": [\"${env:HOME}/openocd/tcl\"], \"svdFile\": \"${env:HOME}/zephyrproject/modules/hal/rpi_pico/src/rp2040/hardware_regs/rp2040.svd\", \"runToEntryPoint\": \"main\", \"postRestartCommands\": [ \"break main\", \"continue\" ] }] } Final Schematic This is the schematic for my setup. Hardware debugger interface on the left, and the target board with the button on the right. Let’s start debugging Open main.c and click the left side of line numbers. Breakpoints will be added accordingly. Don’t forget to compile before debugging. Then click the Run and Debug icon on the left, and click Start Debugging on top left. Voilà! Let’s check with the serial terminal to see Zephyr console output. I will push the button and check the console output. Awesome! You Can Support My Work Creating projects like this takes a great amount of time. Much appreciated if you consider supporting me so that I can continue projects like this and creating new contents for everyone. You might consider supporting me via GitHub Sponsors, Patreon, or Ko-fi. For links, please see the About page. Final words You can access the Raspberry Pi Pico Zephyr RTOS VS Code project from this link. Don’t forget to check out the Zephyr RTOS Real Application Tutorial series." },{ "title" : "3D printer DIY? or Buy? or... Part 2" ,"category" : "3d printers" ,"tags" : "3d printers, diy" ,"url" : "/posts/2022-05-29-diy-3d-printer-part-2" ,"date" : "May 29, 2022" ,"content" : "If you haven’t read the part 1, please check it out. In this post I will talk about what problems I dealt with and how much it cost. After long search I found a 3 axis robot at an online auction. It was just 10 bucks. I had to pick it up and it took 3 hours to drive but it was worth it. I have already released a YouTube video, so please take a look. Tear down After tear down the robot, here is what I found… It has 24V 10 Amps power supply 3 stepper motors with built in encoders 3 close loop motion controllers A stepper motor mounted on the Z axis Stepper motor driver (Open loop) Optical limit switches for all 3 axises Machine specs Musashi Engineering Desktop robot ShotMaster 500DS   Stroke Resolution Max Speed X,Y 500mm 4.2μ 800mm/s Z 120mm 1μ 170mm/s I should say they made a great job. These machines shouldn’t be wasted. I know, it’s too good for 3D printer. I set a golden rule for myself which is, I will start buying the upgrade parts I mentioned in the part 1 and whenever I feel that the project will fail, I will use those upgrade parts in the new cheap 3D printer. But I should say I’m not a quitter. Tasks and problems Original controller is not usable Robot has RS232C interface and specific protocol. I was planning to change marlin firmware to send coordinates over RS232C. After digging marlin stepper pulse source code and asking about it marlin community in discord, I found that It’s not just moving each axis to desired position. Extra control pulses are used for retraction etc. I had to remove existing controller board and drive axises from 3D printer controller. Actually this made things simpler. Marlin will be full control of each axis. After digging some time I found motion controller pinouts. It uses RS422 for each direction. I made a circuit board to convert TTL direction and pulse signals to RS422 signals and connect between motion controllers and 3D printer controller. Schematic diagram looks like this. Making a direct drive extruder I used the aluminum plate came with the machine and a few heatsinks as a material. As I mentioned before we have 4th axis stepper motor, but it is too small for extruder feeder. I wanted to use the original stepper driver so I found 5 pole stepper motor at an online auction for 8 bucks. I also bought metal extruder feeder components and mounted on the stepper motor. Upgrading extruder feeder stepper driver After testing the extruder feeder stepper, it was skipping steps. I realized that the torque wasn’t enough. Checking the data sheet of driver, I found that the driver had current limit setting. Even at the maximum current setting, the torque wasn’t enough. I checked the Oriental motors catalog, they had another model for higher current. Driver model Motor rated current DFC5103P 0.35 A/phase DFC5107P 0.75 A/phase What component is used for current limiting? For sure Cement resistors. There were 2 on the driver board. When I looked for higher current model, those resistor values were different from mine, so I ordered the resistors and changed it. It worked as I expected. With this, Oriental motor DFC5103P was upgraded to DFC5107P. Putting all together After finishing extruder I mounted that to the Z axis. Since the Z axis could only move 120mm, I had to raise the base, and to do so I used a cardboard for testing. Don’t judge me ok, I couldn’t find anything better than that. The controller was ready, necessary cabling done, belt tensioning done, pid calibration done, step calibration done. Next step is printing something! First print and layer shifting problem I had to make sure I could use it as a 3D printer to continue further tasks. I printed the test cube. Here is what I got. It was really frustrating. Everything seemed right. After asking marlin community in discord, one of them pointed me the right direction and told me that someone with external motor drivers had the problem before, and advised me a few things and one of them was inverting steps, and it did the trick. #define INVERT_X_STEP true #define INVERT_Y_STEP true Upgrading the Z-axis I had to replace Z axis with something else. I can’t print on cardboard forever, right? Then I started digging online auction once again, and I found IAI single axis Robo Cylinder for 25 bucks. The original controller was incompatible with pulse drive. The settings can be changed but I didn’t have the cable nor software. I decided to use IAI Robo Cylinder mechanic with the existing Z axis motor. I removed the motor and made a coupler identical to original one. I made necessary parts to mount the extruder module to cylinder and cylinder to machine. After making motor mounting plate, I used hex spacers for mounting it. Yeah! Mounting plate hole could be cleaner, but it just does the job and the mess isn’t visible when mounted. With this, maximum print area will be 500x500x200mm. Safety feature This machine has transition board on it. I manage to add electrical emergency stop feature by jumpering and adding some components. When the machine is powered on, it starts in emergency mode. Reset button needs to be pushed to release from emergency mode and power up the motion controllers. When emergency stop button is pushed, motion controllers are power-down. Even after releasing emergency stop button, reset button needs to be pushed to start the machine cycle. It’s one of the safety measures in industry, requiring 2 actions from the user. Cable drag chain installation Finally, the cabling. I bought the cable carriers for y and Z axises and mounted it. Cabling took quite some time. It wasn’t easy, but in the end it looks good, doesn’t it? Part cooling duct After searching on the Thingiverse, I found some designs. I imported the STL files to the Tinkercad and put all things together. This is the result. Auto bed leveling You may wonder about inductive proximity sensor mounted on the Z axis. After testing it, repeatability wasn’t good enough in my setup and currently I’m not using it. Power consumption After checking the power consumption, I think this power supply is sufficient for the job. State Current Idle(EMG on) 0.638A Servo on idle 1.6A Homing max 1.6A Nozzle temp 195C 3A Nozzle set temp reached 2A Printing max 3A - Power Supply : 24V 10A (TDK LAMBDA ZWS240PAF-24) - Heater : 24V 1.66A (40W) Final costs Budget plan Option 3 DIY + junk 3 axis robot + Upgrades Junk 3 axis robot : $60 Upgrades : $160 Total cost : $220 Actual costs 3 axis robot junk $10 IAI Robo Cylinder junk $25 Hotend MK8 24V 40W $22.67 Hotend silicon cover   $1.76 Extruder MK8 $9.38 Extruder feeder stepper junk $8 Controller Bigtreetech SKR v1.3 $24.24 Touch panel Bigtreetech TFT 3.5 V3.0 $31.28 Cable drag chain   $16.97 Part cooler fan 50x50x15mm $3.87 Extuder cooler fan Noctua NF-A4x10 FLX $17.95 Signal converter pcb   $17.37 Parts on hand   $0 Total spend:   $188.49 Among the advantages I talked about in the part 1, for me being a maker, I think I was able to contribute to reducing the amount of waste from the perspective of the SDGs, which are the most important. Close-ups For other pictures such as making process, please check out my Instagram page. You can find in About page. You Can Support My Work Creating projects like this takes a great amount of time. Much appreciated if you consider supporting me so that I can continue projects like this and creating new contents for everyone. You might consider supporting me via GitHub Sponsors, Patreon, or Ko-fi. For links, please see the About page. Final words Future plans, motor cover for Z axis, box for controller panel. These are what I can think of." },{ "title" : "3D printer DIY? or Buy? or... Part 1" ,"category" : "3d printers" ,"tags" : "3d printers, diy" ,"url" : "/posts/2022-05-29-diy-3d-printer-part-1" ,"date" : "May 29, 2022" ,"content" : "I made my FDM 3D printer from junk industrial robot. Budget, needs, skills and moral could be different for each person. I will talk about my experience so you can get some ideas. I have already released a YouTube video, so please take a look. Overview Why do I need 3D printer at firsthand? Because 3D printed objects can be modified to meet individual needs. It could help repair damaged parts or make spares for home appliance. This could extend the life of existing products. In this way it could be help to reduce the amount of waste. I believe this could contribute to achieve goal 12 responsible consumption and productions, which is one of the UN’s Sustainable Development Goals. Plus, for a maker 3D printers are essential. FDM 3D printer components Let me give you a quick brief about cartesian FDM 3D printer components. Motion mechanisms, XYZ axises Extruder Cold-end Hot-end Direct drive feeder Power supply Controller User interface How did I decide to make? How did I decide to make instead of buying a brand new one? Let me tell my story. Required specs What are my needs for 3D printer? - Has to be cheap since I'm new in the 3D printing, I need affordable one for learning and experimenting - Spare parts must be affordable and easy to get - Self maintainable - Easy to maintain - Quiet - Safe to use at home environment, like fireproof When I search cheap printers, I found the budget should be around $220. Common problems When I search what problems people have with these printers to make sure there are no mandatory fixes which cost time and money. I found these common problems with most cheap 3D printers and I roughly estimate the cost of upgrades. Plastic extruder feeder problems Cause This is because, as it is made of plastic, after a few weeks of use the filament will erode a hole and drag the filament out. This causes under extrusion. Upgrade / Fix Upgrading to metal extruder feeder. $15 Power supply problems Cause Using cheap power supplies causes various problems. When it’s broken, it will mostly damage the control board and screen, and sometimes it could even catch fire. Upgrade / Fix Replacing reliable branded power supply. $35 Under Extrusion problems Cause The PTFE tube causes too much friction, which leads to under extrusion. Upgrade / Fix Upgrading direct drive extruders but it’s not compatible with all printers. $40 Extruder clogging Cause This is mostly caused by the hotend’s cold side not being properly cooled. Upgrade / Fix Expanding the cold end surface to achieve better cooling. Variable fan speed control for better heat control. $5 Noise Cause Some of the noise sources are cheap motor drives and part cooler fans running at max speed. Upgrade / Fix Upgrading motor drivers, dampers, and controller(fans speed control) $50 + drivers Cabling problems Cause Most cheap printers don’t come with proper cabling and as a result, it causes cable failure. This could cause even fire! Upgrade / Fix Doing cable management, replacing some of connectors and power cables. $15 To me these upgrades or fixes are mandatory. It will cost more than $160. Conclusion of DIY or buy I have two options. - Option 1, Buy - New cheap 3D printer : $220 - Upgrades : $160 - Total cost : $380 - Option 2, DIY + Upgrades - Upgrades : $160 - Mechanics : $150 - Total cost : $310 *Prices could be little off But wait! Considering SDG goal 12, I believe every machine or device manufactured should be used as long as they can be reused in any way but recycled once they have finished their lifespan. While thinking about these, then I realized I had the third option. Maybe even better one. - Option 3 DIY + junk 3 axis robot + Upgrades - Junk 3 axis robot : $60 - Upgrades : $160 - Total cost : $220 Just a plan How about if I buy junk 3 axis robot and build a 3D printer on it using upgrade parts as I mentioned? Pros and cons Pros and cons of the third option Pros: In SDGs perspective, this could reduce waste. I will learn something. If I can find industrial robot, position precision will be glorious. Cons: It will take more time than buy and DIY option. Unexpected problems may occur. Needing some circuits for motor controls etc. Junk can be really scrap and not good at all. Skills and tools Required skills and tools Mechanics Basic skills for drilling holes and taping, making parts, cutting, milling etc. Electronics Enough knowledge of electronic circuits to know how to connect things together safely. Computers Compile open source firmware (marlin) Programming Customize the 3D printer firmware (marlin) for your needs. Tools Various tools for each subject needed and to know how to use them safely. Calibration cube The story hasn’t finished yet but, let me show you the 20mm calibration cube printed with this 3D printer. I have small elephant’s foot issue. I haven’t finished all calibrations yet. As you already know I chose option 3 and it turned out good 3D printer. Close-ups For other pictures such as making process, please check out my Instagram page. You can find in About page. You Can Support My Work Creating projects like this takes a great amount of time. Much appreciated if you consider supporting me so that I can continue projects like this and creating new contents for everyone. You might consider supporting me via GitHub Sponsors, Patreon, or Ko-fi. For links, please see the About page. Next post What problems did I deal with? How much did it cost? I talked about those in Part 2." },{ "title" : "Make your personal website or blog in about 10 minutes." ,"category" : "jekyll" ,"tags" : "jekyll theme" ,"url" : "/posts/2022-03-03-mr-green-jekyll-theme" ,"date" : "Mar 3, 2022" ,"content" : "Click here to see a live demonstration This is my first big project, which I shared with the open source community. Mr. Green is a multilingual theme that allows you to create websites and blogs with Markdown, generate them with Jekyll, and host them for free on GitHub Pages. (Please make sure your website does not violate the GitHub Pages terms of use.) To get started, please visit the Mr. Green theme tutorials playlist. Final words You can access the Mr. Green Jekyll Theme from this link." },{ "title" : "Welcome" ,"category" : "" ,"tags" : "" ,"url" : "/" ,"date" : "Jun 16, 2022" ,"content" : "Mr. Green’s Workshop hopes to contribute to the SDGs by sharing the know-how of transforming old machines electronics etc., into usable ones by reusing them, combining them with new ones or fixing them. Projects and contents are mainly focused on Programming, Home Automation (IoT), Electronics, Microcontrollers, DIY, 3D Printers, Robots, Machining / CNC, Servers and more. Thank you." },{ "title" : "About" ,"category" : "" ,"tags" : "" ,"url" : "/tabs/about.html" ,"date" : "Jun 16, 2022" ,"content" : "Motivation I have worked in different fields and gained different experiences. I think it’s time to give something back. My father always used to say, ”Pay the tax on what you have learned by sharing it with others.”. Why Workshop? As a maker, I like projects that involve software, electronic circuits, and mechanics individually or in combination, so I think the word “Workshop” is the best fit. Sponsorship Creating projects themselves don’t pay the bills. It takes a lot of time and efforts to create and maintain projects. I hope you consider supporting me so that I can continue my work and creating new contents for everyone. You can be one of my GitHub Sponsors (monthly or one time) You can be one of my Patreons (monthly) You can tip me via Ko-fi (one time) Contact me For business inquiries, please use the contact form below." } ]
